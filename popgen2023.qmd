---
title: "Simulations in population genetics"
subtitle: "[PopGen summer course 2023](http://www.popgen.dk/popgen23/)"
author:
  - "Martin Petr"
  - "([CC BY 4.0](https://creativecommons.org/licenses/by/4.0/))"
date: "August 2023"
date-format: "MMMM YYYY"
format:
  revealjs:
    # eval: false
    echo: true
    code-line-numbers: false
    fig-align: center
    slide-number: true
  # html:
  #   # eval: false
  #   echo: true
  #   code-line-numbers: false
  #   fig-align: center
---

# 

::: columns
::: {.column width="70%"}
> Many problems in population genetics cannot be solved by a mathematician, no matter how gifted. \[It\] is already clear that computer methods are very powerful. This is good. It \[...\] **permits people with limited mathematical knowledge to work on important problems** \[...\]
:::

::: {.column width="30%"}
![](images/crow.jpeg)

[James F. Crow](https://en.wikipedia.org/wiki/James_F._Crow) -- [interview](http://www.gnxp.com/blog/2006/06/10-questions-for-jim-crow.php)
:::
:::

# Why use simulations?

1.  Making sense of estimated statistics
2.  Fitting model parameters (i.e. [ABC](https://en.wikipedia.org/wiki/Approximate_Bayesian_computation))
3.  Ground truth for method development

## Making sense of estimated statistics

<center>![](images/fstats_sims.png)</center>

::: aside
Image from [Peter (2016)](https://academic.oup.com/genetics/article/202/4/1485/5930214)
:::

## Fitting model parameters (i.e. [ABC](https://en.wikipedia.org/wiki/Approximate_Bayesian_computation))

<center>![](images/abc_scheme.png){width="50%"}</center>

::: aside
Image from [Wikipedia on ABC](https://en.wikipedia.org/wiki/Approximate_Bayesian_computation)
:::

## Ground truth for method development

<center>![](images/mcmc.png)</center>

::: aside
Image from [Schiffels and Durbin (2014)](https://www.nature.com/articles/ng.3015)
:::

# What does it mean to simulate a genome?

. . .

<br> How would you design an algorithm for a popgen simulation?

</h2>

. . .

<br>What minimum components are needed?

# If we want to simulate population genetics

<br>

. . .

We need *populations*.

. . .

We need *genetics*.

# A chromosome is...

<br>

. . .

...a linear sequence of nucleotides...

-   a list of characters (A/G/C/T nucleotides)
-   a list of 0 or 1 values (ancestral/derived allele)

. . .

... which mutates at a given *mutation rate*,

. . .

... and recombines at a certain *recombination rate*.

# A population is...

<br>

... a collection of *individuals* at a given point in time,

. . .

... each carrying *chromosomes* inherited from its parents.

# Home-brewed single-locus simulation in R

<br>

<h3>"What is the expected trajectory of a (neutral) allele under the influence of genetic drift?"</h3>

## Single-locus simulation

```{r}
#| results: hide
#| code-line-numbers: "|1-3|5|7-8|9-10|12-14|17"
p_0 <- 0.5  # initial allele frequency
N   <- 500  # number of chromosomes in a population
T   <- 500  # number of generations to simulate

p_trajectory <- p_0

# in each generation:
for (gen_i in 2:T) {
  # get the current frequency
  p <- p_trajectory[gen_i - 1] 

  # calculate frequency in the next generation
  p_next <- rbinom(1, N, p) / N 
  p_trajectory[gen_i] <- p_next
}

p_trajectory
```

## $N$ = 500, $p_0 = 0.5$

```{r}
#| code-fold: true
plot(p_trajectory, type = "l", ylim = c(0, 1),
     xlab = "generations", ylab = "allele frequency")
abline(h = p_0, lty = 2, col = "red")
```

## Let's make it a function

**Input:** $p_0$, $N$, and the number of generations

**Output:** allele frequency trajectory vector

```{r}
#| code-line-numbers: true
simulate <- function(p_0, N, T) {
  p_trajectory <- p_0

  for (gen_i in 2:T) {
    p <- p_trajectory[gen_i - 1]
    p_next <- rbinom(1, N, p) / N
    p_trajectory[gen_i] <- p_next
  }

  p_trajectory
}
```

## $N$ = 500, $p_0 = 0.5$ (20 replicates)

```{r}
#| code-fold: true
#| fig-align: center
reps <- replicate(20, simulate(N = 500, p_0 = 0.5, T = 2000))

matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1)
```

## $N$ = 1000, $p_0 = 0.5$ (20 replicates)

```{r}
#| code-fold: true
#| fig-align: center
reps <- replicate(20, simulate(N = 1000, p_0 = 0.5, T = 2000))

matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1)
```

## $N$ = 5000, $p_0 = 0.5$ (20 replicates)

```{r}
#| code-fold: true
#| fig-align: center
reps <- replicate(20, simulate(N = 5000, p_0 = 0.5, T = 2000))

matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1)
```

## $N$ = 10000, $p_0 = 0.5$ (20 replicates)

```{r}
#| code-fold: true
#| fig-align: center
reps <- replicate(20, simulate(N = 10000, p_0 = 0.5, T = 20000))

matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1)
```

## $N$ = 10000, $p_0 = 0.5$ (20 replicates)

```{r}
#| code-fold: true
#| fig-align: center
factors <- MASS::fractions(c(3, 2, 1, 1/2, 1/5, 1/10))
matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1)
abline(v = 10000 * factors, lwd = 5)
```

## Expected allele frequency distribution

::: columns
::: {.column width="50%"}
```{r}
#| code-fold: true
#| fig-align: center
#| fig-height: 10
#| fig-width: 10
#| eval: false
library(ggplot2)
library(dplyr)
library(parallel)

p_0 <- 0.5
N <- 10000
factors <- MASS::fractions(c(3, 2, 1, 1/2, 1/5, 1/10))

final_frequencies <- parallel::mclapply(
  seq_along(factors), function(i) {
    f <- factors[i]
    t <- as.integer(N * f)
    # get complete trajectories as a matrix (each column a single trajectory)
    reps <- replicate(10, simulate(N = N, p_0 = p_0, T = t))
    # only keep the last slice of the matrix with the final frequencies
    data.frame(
      t = sprintf("t = %s * N", f),
      freq = reps[t, ]
    )
  },
  mc.cores = parallel::detectCores()
) %>% do.call(rbind, .)
final_frequencies$t <- forcats::fct_rev(forcats::fct_relevel(final_frequencies$t, sprintf("t = %s * N", factors)))

final_frequencies %>% .[.$freq > 0 & .$freq < 1, ] %>%
ggplot() +
  geom_histogram(aes(freq, y = after_stat(density), fill = t), position = "identity", bins = 100, alpha = 0.75) +
  labs(x = "allele frequency") +
  coord_cartesian(ylim = c(0, 3)) +
  facet_grid(t ~ .) +
  guides(fill = guide_legend(sprintf("time since\nthe start\n[assuming\nN = %s]", N))) +
  theme_minimal() +
  theme(strip.text.y = element_blank(),
        axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15))
```
:::

::: {.column width="50%"}
::: fragment
![*"Diffusion Models in Population Genetics"*, [Kimura (1964)](https://www.jstor.org/stable/3211856#metadata_info_tab_contents)](images/kimura.jpeg)
:::
:::
:::

#  {background-image="images/montypython.jpeg"}

::: fragment
<h1 color="black" style="background-color: white">

But now for something completely different.

</h1>
:::

#  {background-image="images/montypython.jpeg"}

<h1 color="black" style="background-color: white">

Let's talk about<br>"real" simulations!

</h1>

## There are many simulation tools

<br>

The most famous and widely used are [SLiM](https://messerlab.org/slim/) and [*msprime*](https://tskit.dev/msprime/docs/stable/intro.html).

<div>

<br>

Both are very powerful...

... but require quite a bit of programming knowledge\...

... and a lot of code for non-trivial simulations (üêõü™≤üêú).

</div>

::: fragment
<br>

<center><h2>**The exercises will focus on the [*slendr*](http://www.slendr.net)**<br>popgen simulation toolkit for R.</h2></center>
:::

# SLiM

## 

::: columns
::: {.column width="60%"}
<h2>What is SLiM?</h2>

::: fragment
-   **Forward-time simulator**

-   It's fully programmable!
:::

::: fragment
-   Massive library of functions for:
    -   Demographic events
    -   Various mating systems
    -   Selection, quantitative traits, ...
:::

::: fragment
-   \> 700 pages long [manual](https://github.com/MesserLab/SLiM/releases/download/v3.7.1/SLiM_Manual.pdf)!
:::
:::

::: {.column width="40%"}
<center>

![Modified from [Alexei Drummond](http://alexeidrummond.org/bayesian_phylo_lectures/lecture10/)](images/sim_sketches.001.png){width="100%"}

</center>
:::
:::

## Simple neutral simulation in SLiM

```{bash}
#| echo: false
cat examples/script.slim
```

# _msprime_

## 

::: columns
::: {.column width="60%"}
<h2>What is [_msprime_](https://tskit.dev/msprime/docs/stable/intro.html)?</h2>
:::

::: {.column width="40%"}
<center>

![Modified from [Alexei Drummond](http://alexeidrummond.org/bayesian_phylo_lectures/lecture10/)](images/sim_sketches.001.png){width="100%"}

</center>
:::
:::

## 

::: columns
::: {.column width="60%"}
<h2>What is [_msprime_](https://tskit.dev/msprime/docs/stable/intro.html)?</h2>

::: fragment
-   A Python module for writing **coalescent simulations**
:::

::: fragment
-   Extremely fast (genome-scale, population-scale data)
:::

::: fragment
-   You must know Python fairly well to build complex models
:::
:::

::: {.column width="40%"}
<center>

![Modified from [Alexei Drummond](http://alexeidrummond.org/bayesian_phylo_lectures/lecture10/)](images/sim_sketches.002.png){width="100%"}

</center>
:::
:::

## Simple simulation using *msprime*

This is basically the same model as the SLiM script earlier:

```{bash}
#| echo: false
cat examples/script.py
```

source: [link](https://tskit.dev/msprime/docs/stable/demography.html#demographic-models)

# 

<center>

<h2>[www.slendr.net](https://www.slendr.net)</h2>

![](images/slendr_logo.png){width="30%"}

</center>

::: fragment

<center>
<h2>Why a new package?</h2>
</center>

:::

## Spatial simulations!

<center>![](images/animation.gif){width="70%"}</center>

## Why a new package?

::: fragment
-   Most researchers are not expert programmers

-   All but the most trivial simulations require lots of code
:::

::: fragment
-   90% <citation needed> of simulations are basically the same!

    -   create populations (splits and $N_e$ changes)

    -   specify if/how they should mix (rates and times)
:::

::: fragment
-   Lot of code duplication across projects
:::

::: fragment
<center>***slendr*** **makes "standard" simulations trivial _and_<br> unlocks new kinds of spatial simulations**</center>
:::

# Let's get started

## Everything we do will be in R

<br>

Always start your R scripts with this (*):

```{r}
library(slendr)
init_env()
```

<br>

My solutions will also use these two packages:

```{r}
library(ggplot2)
library(dplyr)
```

::: aside
(*) You can safely ignore the message about missing SLiM.
:::

# 

::: {style="text-align: right"}
<h1>*slendr* haiku</h1>
:::

<br>

::: {style="text-align: right"}
Build simple models,

<br>

simulate data from them.

<br>

Just one plain R script.
:::

<!-- ## Workaround for an RStudio bug -->

<!-- RStudio sometimes interferes with Python setup that we need for simulation. To fix this, go to `Tools` -\> `Global Options` in your RStudio and set the following options: -->

<!-- <center>![](images/rstudio_setting.png){width="40%"}</center> -->


## Typical steps of a _slendr_ R workflow

<br>

1.  creating populations
2.  scheduling population splits
3.  programming $N_e$ size changes
4.  encoding gene-flow events
5.  simulation sequence of a given size
6.  computing statistics from simulated outputs

## Creating a `population()`

Each needs a name, size and time of appearance (i.e., "split"):

```{r}
pop1 <- population("pop1", N = 1000, time = 1)
```

. . .

<br>

This creates a normal R object. Typing it out gives a summary:

```{r}
pop1
```

## Programming population splits

Splits are indicated by the `parent = <pop>` argument:

```{r}
pop2 <- population("pop2", N = 100, time = 50, parent = pop1)
```

. . .

<br>

The split is reported in the "historical summary":

```{r}
pop2
```

## Scheduling resize events -- `resize()`

Step size decrease:

```{r}
#| code-line-numbers: "2"
pop1 <- population("pop1", N = 1000, time = 1)
pop1_step <- resize(pop1, N = 100, time = 500, how = "step")
```

<br>

Exponential increase:

```{r}
#| code-line-numbers: "2"
pop2 <- population("pop2", N = 100, time = 50, parent = pop1)
pop2_exp <- resize(pop2, N = 10000, time = 500, end = 2000, how = "exponential")
```

## Tidyverse-style [pipe](https://magrittr.tidyverse.org) `%>%` interface

A more concise way to express the same thing as before.

<br>

Step size decrease:

```{r}
pop1 <-
  population("pop1", N = 1000, time = 1) %>%
  resize(N = 100, time = 500, how = "step")
```

Exponential increase:

```{r}
pop2 <-
  population("pop2", N = 1000, time = 1) %>%
  resize(N = 10000, time = 500, end = 2000, how = "exponential")
```

## A more complex model

```{r}
pop1 <- population("pop1", N = 1000, time = 1)

pop2 <-
  population("pop2", N = 1000, time = 300, parent = pop1) %>%
  resize(N = 100, how = "step", time = 1000)

pop3 <-
  population("pop3", N = 1000, time = 400, parent = pop2) %>%
  resize(N = 2500, how = "step", time = 800)

pop4 <-
  population("pop4", N = 1500, time = 500, parent = pop3) %>%
  resize(N = 700, how = "exponential", time = 1200, end = 2000)

pop5 <-
  population("pop5", N = 100, time = 600, parent = pop4) %>%
  resize(N = 50, how = "step", time = 900) %>%
  resize(N = 250, how = "step", time = 1200) %>%
  resize(N = 1000, how = "exponential", time = 1600, end = 2200) %>%
  resize(N = 400, how = "step", time = 2400)
```

## Each object carries its history!

```{r}
pop5
```

## Last step before simulation: `compile_model()`

<br>

```{r}
model <- compile_model(
  list(pop1, pop2, pop3, pop4, pop5),
  generation_time = 1,
  simulation_length = 3000
)
```

<br>

<center>**Compilation takes a list of model components, performs internal consistency checks, returns a single model object.**</center>

::: aside
The model is also compiled to disk which gives a nice additional layer of reproducibility. The exact location can be specified via ``path=`` argument to `compile_model()`.
:::

## Model summary

Typing the compiled `model` into R prints a brief summary:

```{r}
model
```

## Model visualization

```{r}
#| fig-width: 7
#| fig-align: center
plot_model(model)
```


# Exercise #1

<br><br><br><br>

::: aside
Use [these](https://bodkan.quarto.pub/2023-08-23-ku-popgen23-onepage/) one-page handouts for reference.
:::

## Exercise #1 --- write your own model!

::: columns

::: {.column width="50%"}
![](images/intro_model1.png)
:::

::: {.column width="50%"}

::: {.fragment}
Start a new R script in [RStudio](http://emily.popgen.dk:3838/) with the following 'template':

```{r}
#| eval: false
library(slendr)
init_env()

chimp <- population(...)
# <... rest of your code ...>

model <- compile_model(
  populations = list(chimp, ...),
  generation_time = 30
)

plot_model(model) # verify visually
```
:::
:::

:::

::: fragment
Don't worry about gene flow yet. We will add it at a later stage.
:::

# Exercise #1 --- solution








#

<h1>So now we can<br>write a `model`</h1>









## How do we simulate from it?

*slendr* has two built-in simulation engines:

- SLiM engine ([source](https://github.com/bodkan/slendr/blob/main/inst/scripts/script.slim))
- *msprime* engine ([source](https://github.com/bodkan/slendr/blob/main/inst/scripts/script.py))

. . .

<br> This is all that's needed to simulate data:

```{r}
#| eval: false
ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8)
```

. . .

<center>

<br>

<h3>**You don't have to write *msprime* or SLiM code!**</h3>

</center>



# The output of a *slendr* simulation is a **tree sequence (`ts`)**

## What is tree sequence?

![](images/tree_sequence_diagram_no_muts.png){width="80%" fig-align="center"}

-   a record of full genetic ancestry of a set of samples
-   an encoding of DNA sequence carried by those samples
-   an efficient analysis framework

# Why tree sequence?

<br>

<h3>Why not VCF, or some genotype table?</h3>

## What we usually have

<center>![](images/vcf_screenshot.png){width="90%"}</center>

## What we usually *want*

A representation of our samples' history:

<center>![](images/tree_sequence_diagram_no_muts.png)</center>

::: fragment
<center><h3>**This is exactly what a tree sequence *is*!**</h3></center>
:::

## The magic of tree sequences

They allow computing of popgen statistics *without genotypes*!

<center>![](images/tree_sequence_diagram_no_muts.png)</center>

## The magic of tree sequences

They allow computing of popgen statistics *without genotypes*!

<center>

![](images/tree_sequence_diagram_no_muts.png)

</center>


Because of a "duality" between mutations and branch lengths.

::: aside
[Ralph et al. (2020)](https://academic.oup.com/genetics/article/215/3/779/5930459)
:::




## Coalescent and mutation processes can be decoupled

<center>

![](images/tree_sequence_diagram_no_muts.png)

</center>



## Coalescent and mutation processes can be decoupled

<center>

![](images/tree_sequence_diagram.png)

::: fragment
<h3>This means we can add mutations<br>*after* the simulation with `ts_mutate()`.</h3>
:::

</center>






<!-- ## Tree-sequence simulation in practice -->

<!-- Let' say we have a compiled `model` object. -->

<!-- Then, we can simulate a tree sequence like this: -->

<!-- ```{r} -->
<!-- ts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) -->
<!-- ``` -->

<!-- But we can also simulate mutations like this: -->

<!-- ```{r} -->
<!-- ts <- -->
<!--   msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) %>% -->
<!--   ts_mutate(mutation_rate = 1e-8) -->
<!-- ``` -->

<!-- <br> -->

<!-- <center>We will be using `ts_mutate()` throughout.</center> -->









<!-- ## Tree sequences are _very_ efficient -->

<!-- <br> -->

<!-- This simulates 2 $\times$ 10000 chromosomes of 100 Mb: -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- pop <- population("pop", time = 1e6, N = 10000) -->
<!-- model <- compile_model(pop, generation_time = 30, direction = "backward") -->
<!-- ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8) -->
<!-- ``` -->

<!-- . . . -->

<!-- <br> -->

<!-- **Runs in less than 30 seconds on my laptop!** -->

<!-- **Takes about 66 Mb of memory!** -->

<!-- ## How does this work?! -->

<!-- . . . -->

<!-- <center> -->

<!-- ![](images/tables.jpeg) -->

<!-- <center> -->

<!-- ## Tree-sequence tables -->

<!-- ::: row -->
<!-- ::: columns -->
<!-- ::: {.column width="60%"} -->
<!-- A tree (sequence) can be represented by -->

<!-- ::: incremental -->
<!-- -   a table of <font color="orange">n</font><font color="green">o</font><font color="darkblue">d</font><font color="green">e</font><font color="darkblue">s</font>, -->
<!-- -   a table of [edges]{.underline} between nodes, -->
<!-- -   a table of <font color="red">mutations</font> on edges -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: {.column width="40%"} -->
<!-- <br> -->

<!-- <center>![](images/tree_diagram.png)</center> -->
<!-- ::: -->
<!-- ::: -->
<!-- ::: -->

<!-- . . . -->

<!-- <center> -->

<!-- <h3>**A set of such tables is a tree sequence.**</h3> -->

<!-- </center> -->

<!-- ::: aside -->
<!-- You can find much more information in  ([tskit docs](https://tskit.dev/tutorials/tables_and_editing.html)) -->
<!-- ::: -->

<!-- ## Tree-sequence tables in practice -->

<!-- ::: columns -->
<!-- ::: {.column width="50%"} -->
<!-- ```{r} -->
<!-- #| echo: false -->
<!-- #| fig-height: 13 -->
<!-- set.seed(123) -->

<!-- ts <- msprime(model, sequence_length = 1e6, recombination_rate = 1e-8, random_seed = 42) %>% ts_mutate(1e-8, random_seed = 42) -->

<!-- # make a tiny example simplified tree sequence -->
<!-- ts_tiny <- ts_samples(ts) %>% sample_n(4) %>% pull(name) %>% ts_simplify(ts, simplify_to = .) -->
<!-- # extract tree #1 as an ape tree and also a tskit tree -->
<!-- t_phylo <- ts_phylo(ts_tiny, 1, quiet = TRUE) -->
<!-- t_tskit <- ts_tree(ts_tiny, 1) -->

<!-- # plot the phylo tree with ape -->
<!-- suppressPackageStartupMessages(library(ggtree)) -->
<!-- nodes <- ts_nodes(t_phylo) %>% as_tibble %>% dplyr::select(node = phylo_id, pop, node_id) -->
<!-- ggtree(t_phylo, branch.length = "none") %<+% nodes + -->
<!--   geom_label(aes(label = node_id), size = 15) +  -->
<!--   guides(color = "none") -->
<!-- ``` -->
<!-- ::: -->

<!-- ::: {.column width="50%"} -->
<!-- ::: fragment -->
<!-- nodes: -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- ts_nodes(t_phylo) %>% head(3) %>% .[, c("node_id", "pop_id", "time")] %>% as.data.frame() -->
<!-- ``` -->
<!-- ::: -->

<!-- ::: fragment -->
<!-- edges: -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- ts_edges(t_phylo) %>% head(3) %>% .[, c("child_node_id", "parent_node_id")] %>% as.data.frame() -->
<!-- ``` -->
<!-- ::: -->

<!-- ::: fragment -->
<!-- mutations: -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- ts_table(ts_tiny, "mutations") %>% filter(node %in% c(53, 22, 20, 74, 9)) %>% head(3) %>% .[, c("id", "site", "node", "time")] %>% as.data.frame() -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: -->
<!-- ::: -->





## Let's take the `model` from earlier...

```{r}
#| fig-align: center
#| echo: false
plot_model(model)
```

## ... and simulate data from it

<br>

In our script we'll have something like this:

```{r}
#| eval: false
<... population definitions ...>

model <- compile_model(...)
  
ts <-
  msprime(model, sequence_length = 50e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)
```

```{r}
#| echo: false
ts <-
  msprime(model, sequence_length = 50e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)
```

::: fragment
<br>

<center><h2>How do we work with this `ts` thing?</h2></center>
:::

<!-- ## Conversion to other genotype formats -->

<!-- If you have a tree-sequence object `ts`, you can do... -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- ts_vcf(ts, path = "path/to/a/file.vcf.gz") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- ts_eigenstrat(ts, prefix = "path/to/eigenstrat/prefix") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- ts <- ts_simplify(ts, simplify_to = c("pop1_1", "pop2_1")) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ts_genotypes(ts) -->
<!-- ``` -->


## *slendr*'s R interface to [*tskit*](https://tskit.dev/tskit)

<center>

![](images/slendr_tskit.png)

This [R interface](https://www.slendr.net/reference/index.html#tree-sequence-loading-and-processing) links to Python methods implemented in [*tskit*](https://tskit.dev/tskit/docs/stable/python-api.html#statistics).

</center>

## Extracting sample information

Let's say we have a `ts` output from this `model`:

```{r}
#| fig-align: center
#| echo: false
#| fig-width: 8
plot_model(model)
```

## Extracting sample information

We can get recorded samples with `ts_samples()`:

::: columns
::: {.column width="55%"}
```{r}
#| eval: false
ts_samples(ts)
```

```{r}
#| echo: false
#| output-location: fragment
ts_samples(ts) %>% head(5)
```
:::

::: {.column width="2%"}
¬†
:::

::: {.column width="43%"}
::: fragment
```{r}
ts_samples(ts) %>% count(pop)
```
:::
:::
:::


::: fragment

<br>

Sometimes a shortcut `ts_names()` can be useful:

```{r}
#| eval: false
ts_names(ts)
```

```{r}
#| echo: false
ts_names(ts) %>% head(5)
```


:::

# Analyzing tree sequences with *slendr*

## Example: allele frequency spectrum

```{r}
#| echo: false
pop <- population("pop", N = 10000, time = 1)

model <- compile_model(pop, generation_time = 1, simulation_length = 10000)

ts <-
  msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)
```


```{r}
#| echo: false
set.seed(42)
```

::: columns
::: {.column width="45%"}

Sample 5 individuals:

```{r}
names <- ts_names(ts)[1:5]
names
```

::: {.fragment}

<br>

Compute the AFS:

```{r}
afs <- ts_afs(ts, list(names))

afs[-1]
```
:::

:::

::: {.column width="2%"}
¬†
:::

::: {.column width="53%"}
::: fragment
```{r}
#| eval: false
plot(afs[-1], type = "b",
     xlab = "allele count bin",
     ylab = "frequency")
```

```{r}
#| echo: false
#| fig-height: 8
plot(afs[-1], type = "b",
     xlab = "allele count bin",
     ylab = "frequency", lwd = 3,
     cex = 1.5, cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
```
:::
:::
:::

# Exercise #2

## Exercise #2 --- estimating $N_e$ from AFS

```{r}
#| echo: false
set.seed(42)
TRUE_NE <- 6543

pop <- population("pop", N = TRUE_NE, time = 100000)
model <- compile_model(pop, generation_time = 1, direction = "backward")

ts <-
  msprime(model, sequence_length = 10e6, recombination_rate = 1e-8, random_seed = 42) %>%
  ts_mutate(mutation_rate = 1e-8, random_seed = 42)

samples <- ts_samples(ts) %>% sample_n(10) %>% pull(name)

afs_observed <- ts_afs(ts, list(samples), polarised = TRUE)
```

You sequenced 10 samples from a population and computed this AFS vector (# singletons, doubletons, etc.):

<!-- ```{r} -->

<!-- #| echo: false -->

<!-- dput(as.vector(observed_afs)) -->

<!-- ``` -->

```{r}
afs_observed <- c(2520, 1449, 855, 622, 530, 446, 365, 334, 349, 244,
                  264, 218,  133, 173, 159, 142, 167, 129, 125, 143)
```

. . .

You know that the population had constant $N_e$ somewhere between 10000 and 30000 for the past 100,000 generations.

. . .

<hr>

**Use *slendr* to guess the true value of** $N_e$ given the observed AFS by running single-population simulations of different $N_e$ and comparing `ts_afs()` results to `afs_observed`.

## Exercise #2 -- hints

1.  Write an R function (in a new script) that gets $N_e$ as input, creates a *slendr* population, compiles a model, simulates a tree sequence, runs `ts_afs()` on it, and returns the AFS.

2.  Find the $N_e$ value that will give the closest AFS to the observed one. For instance, you could:

    -   a ) Plot simulated AFS for different $N_e$ with the AFS and just eyeball $N_e$ value that looks correct from a graph.

    -   b ) Simulate AFS automatically in steps of possible $N_e$ values and find the [closest matching](https://en.wikipedia.org/wiki/Mean_squared_error) one.

## Exercise #2 solution -- grid search
